from numpy import ndarray
from typing import Optional, Union, Callable
import numpy as np
from mazepy.datastruc.variables import Variable1D, VariableBin
from mazepy.datastruc.kernel import GaussianKernel1d, UniformKernel1d

Kernels = Union[GaussianKernel1d, UniformKernel1d, ndarray]

class _ProcessedNeuralActivityBase(ndarray):
    def __new__(cls, activity: ndarray) -> '_ProcessedNeuralActivityBase': ...
    def __array_finalize__(self, obj: Optional[ndarray]) -> None: ...
    def __init__(self, activity: ndarray, ) -> None: ...
    @property
    def n_neuron(self) -> int: ...
    @property
    def n_bin(self) -> int: ...
    def reset_nan(self) -> None: ...
    def smooth(self, kernel: Kernels) -> ndarray: ...
    def to_array(self) -> ndarray: ...

class TuningCurve(_ProcessedNeuralActivityBase):
    occ_time: np.ndarray
    
    def __new__(cls, activity: ndarray, occu_time: np.ndarray) -> 'TuningCurve': ...
    def __array_finalize__(self, obj: Optional[ndarray]) -> None: ...
    def __init__(self, activity: ndarray, occu_time: np.ndarray) -> None: ...
    def get_argpeaks(self) -> ndarray: ...
    def get_peaks(self) -> ndarray: ...
    def get_fields(self) -> list[dict]: ...
    def smooth(self, kernel: Kernels) -> 'TuningCurve': ...
    
class NeuralTrajectory(_ProcessedNeuralActivityBase):
    time: Union[Variable1D, ndarray]
    variable: Optional[VariableBin]
    
    def __new__(cls, neural_trajectory: ndarray, time: Union[Variable1D, ndarray], variable: Optional[VariableBin] = None) -> 'NeuralTrajectory': ...
    def __array_finalize__(self, obj: Optional[ndarray]) -> None: ...
    def __init__(self, neural_trajectory: ndarray, time: Union[Variable1D, ndarray], variable: Optional[VariableBin] = None) -> None: ...
    def smooth(self, kernel: Kernels) -> 'NeuralTrajectory': ...
    def clip(self, indices: ndarray) -> 'NeuralTrajectory': ...
    def clip_within_trials(self, time_begs: np.ndarray, time_ends: np.ndarray) -> 'NeuralTrajectory': ...
    def clip_inter_trials(self, time_begs: np.ndarray, time_ends: np.ndarray) -> 'NeuralTrajectory': ...
    
class _NeuralActivityBase(ndarray):
    time: Union[Variable1D, ndarray]
    variable: Optional[VariableBin]
    
    def __new__(cls, activity: ndarray, time: Variable1D, variable: Optional[VariableBin]) -> '_NeuralActivityBase': ...
    def __array_finalize__(self, obj: Optional[ndarray]) -> None: ...
    def __init__(self, activity: ndarray, time: Variable1D, variable: Optional[VariableBin]) -> None: ...
    @property
    def n_neuron(self) -> int: ...
    def remove_nan(self) -> None: ...
    def to_array(self) -> ndarray: ...

class SpikeTrain(_NeuralActivityBase):
    time: Union[Variable1D, ndarray]
    variable: Optional[VariableBin]
    
    def __new__(cls, activity: ndarray, time: Variable1D, variable: Optional[VariableBin]) -> 'SpikeTrain': ...
    def __array_finalize__(self, obj: Optional[ndarray]) -> None: ...
    def __init__(self, activity: ndarray, time: Variable1D, variable: Optional[VariableBin]) -> None: ...
    def get_dt(self, t_interv_limits: Optional[float] = None) -> np.ndarray: ...
    def calc_total_time(self, t_interv_limits: Optional[float] = None) -> float: ...
    def calc_occu_time(self, t_interv_limits: Optional[float] = None, nbins: Optional[tuple] = None) -> np.ndarray: ...
    def calc_spike_count(self, mode: str = 'sum', nbins: Optional[tuple] = None) -> np.ndarray: ...
    def calc_mean_rate(self, t_interv_limits: Optional[float] = None) -> ndarray: ...
    def calc_variable_trajectory(self, traj_time: Union[Variable1D, ndarray]) -> Optional[Variable1D]: ...
    def calc_neural_trajectory(self, t_window: float, step_size: Optional[float] = None) -> NeuralTrajectory: ...
    def calc_tuning_curve(self, nbins: int, is_remove_nan: bool = True, t_interv_limits: Optional[float] = None, kilosort_spikes: Optional[np.ndarray] = None, kilosort_variables: Optional[Variable1D] = None) -> TuningCurve: ...
    @property
    def n_neuron(self) -> int: ...
    def remove_nan(self) -> None: ...
    def to_array(self) -> ndarray: ...

class CalciumTraces(_NeuralActivityBase):
    time: Union[Variable1D, ndarray]
    variable: Optional[VariableBin]

    def __new__(cls, activity: ndarray, time: Variable1D, variable: Optional[VariableBin]) -> 'SpikeTrain': ...
    def __array_finalize__(self, obj: Optional[ndarray]) -> None: ...
    def __init__(self, activity: ndarray, time: Variable1D, variable: Optional[VariableBin]) -> None: ...
    def binarize(self, thre: float = 3., func: Callable = np.nanstd) -> SpikeTrain: ...
    @property
    def n_neuron(self) -> int: ...
    def remove_nan(self) -> None: ...
    def to_array(self) -> ndarray: ...

class RawSpikeTrain(_NeuralActivityBase):
    time: Union[Variable1D, ndarray]
    variable: Optional[VariableBin]
    
    def __new__(cls, activity: ndarray, time: Variable1D, variable: Optional[VariableBin]) -> 'SpikeTrain': ...
    def __array_finalize__(self, obj: Optional[ndarray]) -> None: ...
    def __init__(self, activity: ndarray, time: Variable1D, variable: Optional[VariableBin]) -> None: ...
    @property
    def n_neuron(self) -> int: ...
    def remove_nan(self) -> None: ...
    def to_array(self) -> ndarray: ...
    
def convert_kilosort_spike_train(activity: ndarray) -> ndarray: ...

class KilosortSpikeTrain(ndarray):
    variable: Optional[VariableBin]
    time: ndarray
    
    def __new__(cls, activity: ndarray, time: Variable1D, variable: Optional[VariableBin]) -> 'SpikeTrain': ...
    def __array_finalize__(self, obj: Optional[ndarray]) -> None: ...
    def __init__(self, activity: ndarray, time: Variable1D, variable: Optional[VariableBin]) -> None: ...
    def process(self, activity: np.ndarray) -> np.ndarray: ...
    @property
    def n_neuron(self) -> int: ...
    @property
    def n_spikes(self) -> int: ...
    @staticmethod
    def get_spike_train(activity: np.ndarray, time: Union[Variable1D, np.ndarray], variable: Optional[VariableBin] = None) -> SpikeTrain: ...
    def remove_nan(self) -> None: ...
    def to_array(self) -> ndarray: ...
    def to_standard_form(self) -> SpikeTrain: ...
    @staticmethod
    def to_kilosort_form(spikes: SpikeTrain) -> 'KilosortSpikeTrain': ...